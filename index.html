<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Event Loop</title>

		<link rel="stylesheet" href="css/reset.css">
		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/monokai.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<!-- SLIDE 1 -->
				<section>
					<h2>Event Loop</h2>
				</section>
				<!-- SLIDE 2 -->
				<section>
					<h2>JS is single-threaded</h2>
					<p class="fragment fade-in">One piece of code at a time</p>
					<p class="fragment fade-in">Every function call is added to the call stack</p>
					<aside class="notes">
						Javascript is a single-threaded language.
						***CLICK***

						This effectively means that it is not capable of running several blocks of code simultaneously.

						***CLICK***
						To handle all the sinchronous calls, javascript uses the call stack which we will be covering next.
				</aside>
				</section>
				<!-- SLIDES 3-5 -->
				<section>
					<section>
						<h4>Call Stack</h4>
						<img src="images/animation.gif">
						<aside class="notes">
							In this example, we see a script with 3 functions called one by one. The next function is called when the previous one has finished.
							All the functions are added to the stack. As you probably know, stack is a data structure that makes use of LIFO approach (last in first out).
							The last function added to the stack is removed first.

							There's actually a mistake in the slide: the console log statement is a nested function. So it had to be put on top of the calling function in the call stack.

						</aside>
					</section>
					<section>
							<h4>Nested Call Stack</h4>
							<img src="images/nested call-stack.jpg">
						<aside class="notes">
								Here's the same idea, but this time the function calls are deeply nested. Sorry, I didn't have enough patience to animate this for you, but you get the idea.
								'baz' calls 'foo', 'foo' calls 'bar', 'bar' logs 'bar' to the console. They stack up until the very last one is executed and then the stack is cleared.

								The console.log() statement takes almost no time to execute. But if you have a for or a while loop in your code, clearing the call stack may take a noticeable amount of time.
						</aside>
					</section>
				</section>
				<!-- SLIDES 6- -->
				<section>
					<section>
						<h2>Why this approach doesn't always work?</h2>
						<aside class="notes">
								Why is that bad actually?
						</aside>
					</section>
					<section>
							<h3>Problems</h3>
							<ul>
								<li class="fragment fade-in" style="color: red">Poor user experience</p>
								<li class="fragment fade-in" style="color: red">Any task running blocks any interaction with the web-browser (blocking script)</p>
								<li class="fragment fade-in" style="color: red">Stack overflow</p>
							</ul>
						<aside class="notes">
								***CLICK***
								First, the user experience may deteriorate. You may literally notice the slowness of the web-page.

								***CLICK***
								Because of how the browsers are designed, the user interface may be completely blocked by the occupied call stack.

								***CLICK***
								Finally, on a rare occasion we may just run into a stack overflow. Stack overflow is a situation when the amount of stack calls exceeds the limit set by the browser.
						</aside>
					</section>
					<section>
							<h3>Time-consuming operations</h3>
							<ul>
								<li class="fragment fade-in">Web requests</p>
								<li class="fragment fade-in">Processing a lot of data</p>
							</ul>
						<aside class="notes">
								So which operations are the most time-consuming?

								***CLICK***
								Web requests - they don't guarantee any response time. The same applies to image loading which takes up to 50% of the web traffic.
								If you try to do that with a call stack, your website will turn into a time-machine throwing the user back to the age of a dial-up connection.

								***CLICK***
								Data processing should be pretty self-explaining.
								Sounds like we're in trouble, right?

								***CLICK***
						</aside>
					</section>
					<section>
						<img src="images/were-doomed.jpg">
						<p class="fragment fade-in">not really...</p>
					</section>
				</section>
				<section>
					<section>
							<h3>Asynchronous calls</h3>
							<p class="fragment fade-in">Uses runtime environment</p>
						<aside class="notes">
								Javascript can't run several things at the same time, right? Correct. But it can actually use it's runtime environment to make asynchronous calls.
								A runtime environment is, simply speaking, the context in which your code is executed. It could be a web-brower, a server or an application.
						</aside>
					</section>
					<section>
							<h3>Browser (WEB APIs)</h3>
							<ul class="fragment fade-in" style="margin-bottom: 30px;">
								<li>DOM Events (click, etc)</li>
								<li>XMLHttpRequests(AJAX, Fetch)</li>
								<li>Hundreds of them!</li>
							</ul>
							<h3>Node.js</h3>
							<ul class="fragment fade-in">
								<li>C/C++ APIs</li>
								<li>Libraries</li>
							</ul>
						<aside class="notes">
							So which APIs can actually handle asynchronous calls?
						</aside>
					</section>
					<section>
							<h4>Web APIs</h4>
							<img src="images/animation2.gif">
						<aside class="notes">
								Here's a little example of the asynchronous code implemented with the help of the setTimeout method.

								When the API receives the function call, it starts the timer. Once the countdown is finished, it passes the callback function to the task queue.

								Queue is another data structure you are already familiar with. It makes use of the FIFO method which stands for First [item] In First [item] Out. The main goal of the task que is to maintain
								the order in which the tasks should be passed to the call stack.

								Once the call stack is empty, the first item of the task queue is passed to the call stack for execution.
								So far looks pretty straightforward, right? Unfortunately, it's a little more complicated.
								***CLICK***
						</aside>
					</section>
					<section>
						<img src="images/complicated.jpg">
					</section>
				</section>
				<section>
					<section>
						<h2>Queues</h2>
						<p class="fragment fade-in">3 categories of queues to handle async calls</p>
						<ol>
							<li	class="fragment fade-in">Tasks</li>
							<li	class="fragment fade-in">Microtasks</li>
							<li	class="fragment fade-in">Animation Callbacks</li>
						</ol>
						<aside class="notes">
							We have to deal with not one, but 3 queues.

							***CLICK***

							We've already got familiar with the task queue (aka MacroTask queue). Macrotasks are enqueued by setTimeout, setInterval, setImmediate functions and also DOM Events.

							The other two are:

							***CLICK***

							Microtasks queue and...

							***CLICK***

							Animation Callbacks
							</table>
						</aside>
					</section>
					<section>
						<h3>Animation callbacks</h3>
						<ul class="fragment fade-in">
							<li>requestAnimationFrame()</li>
							<li>Page resize and other events affecting the display</li>
							<li>GIF rendering</li>
						</ul>
						<aside class="notes">
								Animation callbacks is a completely different story. We will not be covering them in-depth today, but basically,
								the browser puts animation callbacks to a separate queue and renders or repaints the page when necessary.
						</aside>
					</section>
					<section>
						<h3>Micro-tasks</h3>
						<p class="fragment fade-in">Mostly promises</p>
						<aside class="notes">
								Micro-tasks queue was introduced in ES6. It's dedicated to handling Promises. Which means it also takes care of anything associated with promises (fetch, for example);
						</aside>
					</section>
					<section>
						<h4>The 3 queues</h4>
						<img src="images/animation-3.gif">
						<aside class="notes">
								Here's a little animation I've made for you. It illustrates the priority and the order in which the event loop processes tasks from different queue.

								The highest priority is given to the microtask queue. The event loop attends the microtask queue every time the call stack is cleared and it runs all the tasks from it until it's empty.
								If you add more tasks to the microtask queue during that iteration, they all are going to be processed.

								If the microtask queue is empty, the event loop travels between the macrotask queue and animation queue. The animation queue is processed until all the tasks are gone. However, if new tasks
								are added, they will be ignored until the next iteration.

								Finally, one task from the macrotasks queue is processed on every Event loop iteration.
						</aside>
					</section>
					</section>
				</section>
				<section>
					<section>
						<h2>What is Event Loop?</h2>
					</section>
					<section>
						<h4>The event loop</h4>
						<img src="images/event loop diag.jpg">
						<aside class="notes">
							Event loop is simply a process that constantly checks the state of the call stack and the queues. One increment of the event loop is called the "Tick". Let's look closer at the Tick.
						</aside>
					</section>
					<section>
						<h4>Event loop iteration (tick)</h4>
						<pre><code style="font-size: 16px; line-height: 22px"  data-trim data-noescape data-line-numbers="1-18">
							while(appIsRunning) {
								while (microtasksQueue.hasTasks()) {
									doTask(microTask);
								}

								if (taskQueue.hasTasks()) {
									currentTask = taskQueue.shift();
									doTask(currentTask);
								}

								if (animationQueue.hastasks()) {
									currentTasks = animationQueue;
									for (e in currentTasks) {
										doTask(e);
									}
									render();
								}
							}
						</code></pre>
						<aside class="notes">
							Here's a piece of pseudo-code showing the logic of the event loop iteration.

							While the application is running we check if there are any calls in the microtask queue. If there are any, we process them all.
							Then we move on to the macrotask queue. If there's any task there, we pick one and execute it.
							Finally, we go to the animation queue and process all the tasks from that queue, but ignore any incoming tasks.
						</aside>
					</section>

					<section>
						<h4>The event loop</h4>
						<img src="images/event loop.jpg">
					</section>
					<aside class="notes">
						Let's move on to some real-world examples.
					</aside>
				</section>
				<section>
					<section>
						<h2>Code</h2>
					</section>
					<section>
							<h4>The classic</h4>
							<pre><code style="font-size: 16px; line-height: 22px"  data-trim data-noescape data-line-numbers="1-18">
									const bar = () => console.log('bar')

									const baz = () => console.log('baz')

									const foo = () => {
									  console.log('foo')
									  setTimeout(bar, 0)
									  baz()
									}

									foo()
							</code></pre>
							<p class="fragment fade-in">And the output is...</p>
							<pre class="fragment fade-in"><code style="font-size: 16px; line-height: 22px"  data-trim data-noescape data-line-numbers="1-3">
								//foo
								//baz
								//bar
							</code></pre>
							<aside class="notes">
									This is a classic example. We run all the synchronous code first (which is represented by the "foo" and "baz" functions), and then.
									Despite the fact that we put a zero delay on the timed-out function, it is still taken to the macrotask queue and processed last.
							</aside>
					</section>
					<section>
						<h4>A little trickier example</h4>
						<pre><code style="font-size: 16px; line-height: 22px"  data-trim data-noescape data-line-numbers="1-18">
								console.log('Script start');

								setTimeout(() => {
								  console.log('setTimeout');
								}, 0);

								new Promise((resolve, reject) => {
								    resolve('Promise resolved');
								  }).then(res => console.log(res))
										.catch(err => console.log(err));

								console.log('Script End');
						</code></pre>
						<p class="fragment fade-in">...wait for it...</p>
						<pre class="fragment fade-in"><code style="font-size: 16px; line-height: 22px"  data-trim data-noescape data-line-numbers="1-4">
							//Script start
							//Script End
							//Promise resolved
							//setTimeout
						</code></pre>
						<aside class="notes">
								Another pretty common illustration of the event loop. Even though the timeout was set earlier in the script, the promise has a higher priority and it is processed first.
						</aside>
					</section>
					<section>
						<h4>Another example</h4>
						<pre><code style="font-size: 16px; line-height: 22px"  data-trim data-noescape data-line-numbers="1-18">
							const nextListItem = function(item) {
								item.doSomething()

									if (item) {
											nextListItem();
									}
							};
						</code></pre>
						<img src="images/maximum-call-stack.jpg" class="fragment fade-in" style="width: 850px;">
						<aside class="notes">
								Imagine we pass a huge array to the function and try to run it in the browser. We don't use any async calls to here. If the array is too big, we may end up getting in trouble, right?
								And it goes without saying that a code like this may completely block our webpage.

								But we can re-write the code like this...
						</aside>
					</section>
					<section>
						<h4>Use of async</h4>
						<pre><code style="font-size: 16px; line-height: 22px"  data-trim data-noescape data-line-numbers="1-18">
							const nextListItem = function(item) {

								item.doSomething();
									if (item) {
											setTimeOut(nextListItem, 0);
									}
							};
						</code></pre>
						<p class="fragment fade-in">The recursion is handled by the task queue, not the call stack!</p>
						<aside class="notes">
							It doesn't seem that we've changed much here, but now we can process almost any amount of data without user even realizing it.
						</aside>
					</section>

					<section>
						<p>Let's try the same with a promise?</p>

						<pre><code style="font-size: 16px; line-height: 22px"  data-trim data-noescape data-line-numbers="1-18">
							const nextListItem = function(item) {
									item.doSomething();

									if (item) {
											Promise.resolve()
												.then(nextListItem);
									}
							};
						</code></pre>
						<aside class="notes">
								We love promises, promises are cool, right? Let's try to implement the same. What do you think the output would be?
						</aside>
					</section>

					<section>
						<img src="images/inf-loop.jpg">
						<h4 class="fragment fade-in">OOPS!</h4>
						<aside class="notes">
								Well, it may not be infinite, but it may very well take so long that it would be indistinguishable.
								Because the microtasks queue is processed until it's empty, handling recursion calls with this method is far from optimal.
						</aside>
					</section>
				</section>
				<section>
						<h4 >Conclusion</h4>
						<aside class="notes">
							Event loops is a complicated topic, but it's absolutely necessary to understand the basics. Knowing how the Event Loop works will help you make sure you are in control of your code execution
							and which order the async calls will be running in.
						</aside>
				</section>
				<section>
						<h4>Thank you for attention</h4>
				</section>
			</div>
		</div>

		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true }
				],
				slideNumber: true,
				slideNumber: 'c/t',
				autoPlayMedia: true,
				defaultTiming: 2,
			});
		</script>
	</body>
</html>


